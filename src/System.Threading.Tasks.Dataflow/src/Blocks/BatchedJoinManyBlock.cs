// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
//
// BatchedJoinManyBlock.cs
//
//
// A propagator block that groups individual messages of multiple sources
// into arrays of arrays of those messages.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Threading.Tasks.Dataflow.Internal;

namespace System.Threading.Tasks.Dataflow
{
    /// <summary>
    /// Provides a dataflow block that batches a specified number of inputs of potentially differing types
    /// provided to one or more of its targets.
    /// </summary>
    /// <typeparam name="T">Specifies the type of data accepted by the block's targets.</typeparam>
    [DebuggerDisplay("{DebuggerDisplayContent,nq}")]
    [DebuggerTypeProxy(typeof(BatchedJoinManyBlock<>.DebugView))]
    public sealed class BatchedJoinManyBlock<T> : IReceivableSourceBlock<IList<T>[]>, IDebuggerDisplay
    {
        /// <summary>The size of the batches generated by this BatchedJoinMany.</summary>
        private readonly int _batchSize;
        /// <summary>State shared among the targets.</summary>
        private readonly BatchedJoinBlockTargetSharedResources _sharedResources;
        /// <summary>The targets providing inputs of type T.</summary>
        private readonly BatchedJoinBlockTarget<T>[] _targets;
        /// <summary>The source side.</summary>
        private readonly SourceCore<IList<T>[]> _source;

        /// <summary>Initializes this <see cref="BatchedJoinManyBlock{T}"/> with the specified configuration.</summary>
        /// <param name="batchSize">The number of items to group into a batch.</param>
        /// <param name="joinNumber">The number of targets to join</param>
        /// <exception cref="System.ArgumentOutOfRangeException">The <paramref name="batchSize"/> must be positive.</exception>
        /// <exception cref="System.ArgumentOutOfRangeException">The <paramref name="joinNumber"/> must be positive.</exception>
        public BatchedJoinManyBlock(int batchSize, int joinNumber) :
            this(batchSize, joinNumber, GroupingDataflowBlockOptions.Default)
        { }

        /// <summary>Initializes this <see cref="BatchedJoinManyBlock{T}"/> with the specified configuration.</summary>
        /// <param name="batchSize">The number of items to group into a batch.</param>
        /// <param name="joinNumber">The number of targets to join</param>
        /// <param name="dataflowBlockOptions">The options with which to configure this <see cref="BatchedJoinManyBlock{T}"/>.</param>
        /// <exception cref="System.ArgumentOutOfRangeException">The <paramref name="batchSize"/> must be positive.</exception>
        /// <exception cref="System.ArgumentOutOfRangeException">The <paramref name="joinNumber"/> must be positive.</exception>
        /// <exception cref="System.ArgumentNullException">The <paramref name="dataflowBlockOptions"/> is null (Nothing in Visual Basic).</exception>
        public BatchedJoinManyBlock(int batchSize, int joinNumber, GroupingDataflowBlockOptions dataflowBlockOptions)
        {
            // Validate arguments
            if (batchSize < 1) throw new ArgumentOutOfRangeException(nameof(batchSize), SR.ArgumentOutOfRange_GenericPositive);
            if (joinNumber < 1) throw new ArgumentOutOfRangeException(nameof(joinNumber), SR.ArgumentOutOfRange_GenericPositive);
            if (dataflowBlockOptions == null) throw new ArgumentNullException(nameof(dataflowBlockOptions));
            if (!dataflowBlockOptions.Greedy) throw new ArgumentException(SR.Argument_NonGreedyNotSupported, nameof(dataflowBlockOptions));
            if (dataflowBlockOptions.BoundedCapacity != DataflowBlockOptions.Unbounded) throw new ArgumentException(SR.Argument_BoundedCapacityNotSupported, nameof(dataflowBlockOptions));

            // Store arguments
            _batchSize = batchSize;
            dataflowBlockOptions = dataflowBlockOptions.DefaultOrClone();

            // Configure the source
            _source = new SourceCore<IList<T>[]>(
                this, dataflowBlockOptions, owningSource => ((BatchedJoinManyBlock<T>)owningSource).CompleteEachTarget());

            // The action to run when a batch should be created.  This is typically called
            // when we have a full batch, but it will also be called when we're done receiving
            // messages, and thus when there may be a few stragglers we need to make a batch out of.
            void createBatchAction()
            {
                if (_targets.Any(t => t.Count > 0))
                {
                    _source.AddMessage(_targets.Select(t => t.GetAndEmptyMessages()).ToArray());
                }
            }

            // Configure the targets
            _sharedResources = new BatchedJoinBlockTargetSharedResources(
                batchSize, dataflowBlockOptions,
                createBatchAction,
                () =>
                {
                    createBatchAction();
                    _source.Complete();
                },
                _source.AddException,
                Complete);

            _targets = new BatchedJoinBlockTarget<T>[joinNumber];
            for (int i = 0; i < joinNumber; i++)
            {
                _targets[i] = new BatchedJoinBlockTarget<T>(_sharedResources);
            }

            // It is possible that the source half may fault on its own, e.g. due to a task scheduler exception.
            // In those cases we need to fault the target half to drop its buffered messages and to release its
            // reservations. This should not create an infinite loop, because all our implementations are designed
            // to handle multiple completion requests and to carry over only one.
            _source.Completion.ContinueWith((completed, state) =>
            {
                var thisBlock = ((BatchedJoinManyBlock<T>)state) as IDataflowBlock;
                Debug.Assert(completed.IsFaulted, "The source must be faulted in order to trigger a target completion.");
                thisBlock.Fault(completed.Exception);
            }, this, CancellationToken.None, Common.GetContinuationOptions() | TaskContinuationOptions.OnlyOnFaulted, TaskScheduler.Default);

            // Handle async cancellation requests by declining on the target
            Common.WireCancellationToComplete(
                dataflowBlockOptions.CancellationToken, _source.Completion, state => ((BatchedJoinManyBlock<T>)state).CompleteEachTarget(), this);
#if FEATURE_TRACING
            DataflowEtwProvider etwLog = DataflowEtwProvider.Log;
            if (etwLog.IsEnabled())
            {
                etwLog.DataflowBlockCreated(this, dataflowBlockOptions);
            }
#endif
        }

        /// <summary>Gets the size of the batches generated by this <see cref="BatchedJoinManyBlock{T}"/>.</summary>
        public int BatchSize { get { return _batchSize; } }

        /// <summary>Gets an array of targetq that may be used to offer messages.</summary>
        public ITargetBlock<T>[] Targets { get { return _targets; } }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Sources/Member[@name="LinkTo"]/*' />
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
        public IDisposable LinkTo(ITargetBlock<IList<T>[]> target, DataflowLinkOptions linkOptions)
        {
            return _source.LinkTo(target, linkOptions);
        }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Sources/Member[@name="TryReceive"]/*' />
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
        public bool TryReceive(Predicate<IList<T>[]> filter, out IList<T>[] item)
        {
            return _source.TryReceive(filter, out item);
        }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Sources/Member[@name="TryReceiveAll"]/*' />
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
        public bool TryReceiveAll(out IList<IList<T>[]> items) { return _source.TryReceiveAll(out items); }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Sources/Member[@name="OutputCount"]/*' />
        public int OutputCount { get { return _source.OutputCount; } }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Blocks/Member[@name="Completion"]/*' />
        public Task Completion { get { return _source.Completion; } }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Blocks/Member[@name="Complete"]/*' />
        public void Complete()
        {
            Debug.Assert(_targets.All(t => t != null), "a target is not initialized");

            CompleteEachTarget();
        }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Blocks/Member[@name="Fault"]/*' />
        void IDataflowBlock.Fault(Exception exception)
        {
            if (exception == null) throw new ArgumentNullException(nameof(exception));

            Debug.Assert(_sharedResources != null, "_sharedResources not initialized");
            Debug.Assert(_sharedResources._incomingLock != null, "_sharedResources._incomingLock not initialized");
            Debug.Assert(_source != null, "_source not initialized");

            lock (_sharedResources._incomingLock)
            {
                if (!_sharedResources._decliningPermanently) _source.AddException(exception);
            }
            Complete();
        }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Sources/Member[@name="ConsumeMessage"]/*' />
        IList<T>[] ISourceBlock<IList<T>[]>.ConsumeMessage(
            DataflowMessageHeader messageHeader, ITargetBlock<IList<T>[]> target, out bool messageConsumed)
        {
            return _source.ConsumeMessage(messageHeader, target, out messageConsumed);
        }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Sources/Member[@name="ReserveMessage"]/*' />
        bool ISourceBlock<IList<T>[]>.ReserveMessage(
            DataflowMessageHeader messageHeader, ITargetBlock<IList<T>[]> target)
        {
            return _source.ReserveMessage(messageHeader, target);
        }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Sources/Member[@name="ReleaseReservation"]/*' />
        void ISourceBlock<IList<T>[]>.ReleaseReservation(
            DataflowMessageHeader messageHeader, ITargetBlock<IList<T>[]> target)
        {
            _source.ReleaseReservation(messageHeader, target);
        }

        /// <summary>
        /// Invokes Complete on each target
        /// </summary>
        private void CompleteEachTarget()
        {
            Array.ForEach(_targets, t => t.Complete());
        }

        /// <summary>Gets the number of messages waiting to be processed.  This must only be used from the debugger as it avoids taking necessary locks.</summary>
        private int OutputCountForDebugger { get { return _source.GetDebuggingInformation().OutputCount; } }

        /// <include file='XmlDocs/CommonXmlDocComments.xml' path='CommonXmlDocComments/Blocks/Member[@name="ToString"]/*' />
        public override string ToString() { return Common.GetNameForDebugger(this, _source.DataflowBlockOptions); }

        /// <summary>The data to display in the debugger display attribute.</summary>
        [SuppressMessage("Microsoft.Globalization", "CA1305:SpecifyIFormatProvider")]
        private object DebuggerDisplayContent
        {
            get
            {
                return string.Format("{0}, BatchSize={1}, OutputCount={2}",
                    Common.GetNameForDebugger(this, _source.DataflowBlockOptions),
                    BatchSize,
                    OutputCountForDebugger);
            }
        }
        /// <summary>Gets the data to display in the debugger display attribute for this instance.</summary>
        object IDebuggerDisplay.Content { get { return DebuggerDisplayContent; } }

        /// <summary>Provides a debugger type proxy for the Transform.</summary>
        private sealed class DebugView
        {
            /// <summary>The block being viewed.</summary>
            private readonly BatchedJoinManyBlock<T> _batchedJoinBlock;
            /// <summary>The source half of the block being viewed.</summary>
            private readonly SourceCore<IList<T>[]>.DebuggingInformation _sourceDebuggingInformation;

            /// <summary>Initializes the debug view.</summary>
            /// <param name="batchedJoinBlock">The batched join being viewed.</param>
            public DebugView(BatchedJoinManyBlock<T> batchedJoinBlock)
            {
                Debug.Assert(batchedJoinBlock != null, "Need a block with which to construct the debug view.");
                _batchedJoinBlock = batchedJoinBlock;
                _sourceDebuggingInformation = batchedJoinBlock._source.GetDebuggingInformation();
            }

            /// <summary>Gets the messages waiting to be received.</summary>
            public IEnumerable<IList<T>[]> OutputQueue { get { return _sourceDebuggingInformation.OutputQueue; } }
            /// <summary>Gets the number of batches created.</summary>
            public long BatchesCreated { get { return _batchedJoinBlock._sharedResources._batchesCreated; } }
            /// <summary>Gets the number of items remaining to form a batch.</summary>
            public int RemainingItemsForBatch { get { return _batchedJoinBlock._sharedResources._remainingItemsInBatch; } }

            /// <summary>Gets the size of the batches generated by this BatchedJoin.</summary>
            public int BatchSize { get { return _batchedJoinBlock._batchSize; } }
            /// <summary>Gets the targets.</summary>
            public ITargetBlock<T>[] Targets { get { return _batchedJoinBlock._targets; } }

            /// <summary>Gets the task being used for output processing.</summary>
            public Task TaskForOutputProcessing { get { return _sourceDebuggingInformation.TaskForOutputProcessing; } }

            /// <summary>Gets the DataflowBlockOptions used to configure this block.</summary>
            public GroupingDataflowBlockOptions DataflowBlockOptions { get { return (GroupingDataflowBlockOptions)_sourceDebuggingInformation.DataflowBlockOptions; } }
            /// <summary>Gets whether the block is completed.</summary>
            public bool IsCompleted { get { return _sourceDebuggingInformation.IsCompleted; } }
            /// <summary>Gets the block's Id.</summary>
            public int Id { get { return Common.GetBlockId(_batchedJoinBlock); } }

            /// <summary>Gets the set of all targets linked from this block.</summary>
            public TargetRegistry<IList<T>[]> LinkedTargets { get { return _sourceDebuggingInformation.LinkedTargets; } }
            /// <summary>Gets the target that holds a reservation on the next message, if any.</summary>
            public ITargetBlock<IList<T>[]> NextMessageReservedFor { get { return _sourceDebuggingInformation.NextMessageReservedFor; } }
        }
    }
}
